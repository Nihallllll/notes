  

> [!info] About This Guide

> Master Anchor framework by building real smart contracts with step-by-step explanations

  

---

  

## ğŸ“š Table of Contents

  

> [!abstract]- Quick Navigation

> 1. [[#ğŸš€ 1. ANCHOR PROGRAM STRUCTURE & SETUP|Anchor Program Structure & Setup]]

> 2. [[#ğŸ” 2. THE #[derive(Accounts)] MACRO (CORE SECURITY)|The #[derive(Accounts)] Macro]]

> 3. [[#ğŸ‘¥ 3. ACCOUNT TYPES & VALIDATION|Account Types & Validation]]

> 4. [[#ğŸ—ï¸ 4. DEFINING DATA STRUCTURES WITH #[account]|Defining Data Structures]]

> 5. [[#ğŸ¬ 5. INSTRUCTIONS & THE #[program] MODULE|Instructions & The #[program] Module]]

> 6. [[#ğŸ”‘ 6. PROGRAM DERIVED ADDRESSES (PDAs) IN CODE|PDAs in Code]]

> 7. [[#âš™ï¸ 7. CONSTRAINTS DEEP DIVE|Constraints Deep Dive]]

> 8. [[#âŒ 8. ERROR HANDLING & CUSTOM ERRORS|Error Handling & Custom Errors]]

> 9. [[#ğŸ“¢ 9. EVENTS & LOGGING|Events & Logging]]

> 10. [[#ğŸ”€ 10. CROSS-PROGRAM INVOCATION (CPI)|Cross-Program Invocation]]

> 11. [[#ğŸª™ 11. SPL TOKEN INTEGRATION|SPL Token Integration]]

> 12. [[#ğŸ§ª 12. TESTING ANCHOR PROGRAMS|Testing Anchor Programs]]

> 13. [[#ğŸ› ï¸ 13. ANCHOR CLI & WORKSPACE|Anchor CLI & Workspace]]

> 14. [[#ğŸ“ 14. IDL & CLIENT GENERATION|IDL & Client Generation]]

> 15. [[#ğŸ”’ 15. SECURITY PATTERNS IN CODE|Security Patterns in Code]]

> 16. [[#ğŸš€ 16. ADVANCED TECHNIQUES|Advanced Techniques]]

> 17. [[#ğŸ“¦ 17. DEPLOYMENT & UPGRADES|Deployment & Upgrades]]

> 18. [[#ğŸ’¯ 18. REAL-WORLD EXAMPLE: COMPLETE PROGRAM|Real-World Example]]

  

---

  

## ğŸš€ 1. ANCHOR PROGRAM STRUCTURE & SETUP

  

### 1.1 Project Initialization

  

**Step 1: Create a new Anchor project**

  

```bash

anchor init my_solana_program

cd my_solana_program

```

  

**This creates:**

```

my_solana_program/

â”œâ”€â”€ Anchor.toml Â  Â  Â  Â  Â  # Configuration

â”œâ”€â”€ Cargo.toml Â  Â  Â  Â  Â  Â # Workspace dependencies

â”œâ”€â”€ programs/

â”‚ Â  â””â”€â”€ my_solana_program/

â”‚ Â  Â  Â  â”œâ”€â”€ Cargo.toml Â  Â # Program-specific deps

â”‚ Â  Â  Â  â””â”€â”€ src/

â”‚ Â  Â  Â  Â  Â  â””â”€â”€ lib.rs Â  Â # Your program code

â”œâ”€â”€ tests/

â”‚ Â  â””â”€â”€ my_solana_program.ts Â # TypeScript tests

â””â”€â”€ app/ Â  Â  Â  Â  Â  Â  Â  Â  Â # Frontend placeholder

```

  

### 1.2 Basic Program Structure

  

**File: `programs/my_solana_program/src/lib.rs`**

  

```rust

use anchor_lang::prelude::*;

  

// 1. Declare your program ID

declare_id!("11111111111111111111111111111111");

  

// 2. Define your program module

#[program]

pub mod my_solana_program {

Â  Â  use super::*;

  

Â  Â  // 3. Write your instructions

Â  Â  pub fn initialize(ctx: Context<Initialize>) -> Result<()> {

Â  Â  Â  Â  msg!("Hello, Solana!");

Â  Â  Â  Â  Ok(())

Â  Â  }

}

  

// 4. Define your accounts struct

#[derive(Accounts)]

pub struct Initialize {}

```

  

**What each part does:**

  

| Component | Purpose | Example |

|-----------|---------|---------|

| `declare_id!()` | Program's public address | Generated automatically |

| `#[program]` | Defines instruction module | Contains all functions |

| Function | One instruction | `initialize`, `transfer`, etc. |

| `Context<T>` | Accounts for this instruction | `T` = accounts struct |

| `#[derive(Accounts)]` | Validates accounts | Auto-generates validation |

  

### 1.3 Understanding Context<T>

  

**What is Context?**

  

```rust

pub fn my_instruction(ctx: Context<MyAccounts>, param: u64) -> Result<()> {

Â  Â  // ctx.accounts = all accounts passed in

Â  Â  // ctx.program_id = this program's address

Â  Â  // ctx.bumps = bump seeds for PDAs

Â  Â  // ctx.remaining_accounts = extra accounts

Â  Â  Ok(())

}

  

// MyAccounts is a struct defining which accounts are needed

#[derive(Accounts)]

pub struct MyAccounts<'info> {

Â  Â  pub account1: Account<'info, SomeData>,

Â  Â  pub account2: Signer<'info>,

Â  Â  pub system_program: Program<'info, System>,

}

```

  

**Breaking it down:**

  

- `ctx.accounts` â†’ Access all accounts

- `ctx.program_id` â†’ This program's address

- `ctx.bumps` â†’ PDA bump seeds

- `ctx.remaining_accounts` â†’ Extra accounts beyond declared ones

  

---

  

## ğŸ” 2. THE #[derive(Accounts)] MACRO (CORE SECURITY)

  

### 2.1 What Does #[derive(Accounts)] Do?

  

> [!important] Core Security Foundation

> This macro is THE security foundation of Anchor. It automatically validates that:

> - Accounts are owned by the right program

> - Signers have actually signed

> - PDAs are correctly derived

> - Mutability is respected

  

> [!danger] Without Anchor (Unsafe)

> ```rust

> pub fn transfer(

> Â  Â  from: AccountInfo,

> Â  Â  to: AccountInfo,

> Â  Â  amount: u64,

> ) -> Result<()> {

> Â  Â  // âŒ You must manually verify EVERYTHING:

> Â  Â  // - Is 'from' owned by your program?

> Â  Â  // - Did 'from' sign this transaction?

> Â  Â  // - Is 'to' a valid account?

> Â  Â  // 100+ lines of validation code!

> Â  Â  Ok(())

> }

> ```

  

> [!success] With Anchor (Safe)

> ```rust

> pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {

> Â  Â  // âœ… All validation is automatic!

> Â  Â  // Anchor checked everything before this runs

> Â  Â  Ok(())

> }

>

> #[derive(Accounts)]

> pub struct Transfer<'info> {

> Â  Â  #[account(mut)]

> Â  Â  pub from: Account<'info, UserData>,

> Â  Â  #[account(mut)]

> Â  Â  pub to: Account<'info, UserData>,

> Â  Â  pub signer: Signer<'info>,

> }

> ```

  

### 2.2 Lifetime Parameter ('info)

  

**What is `'info`?**

  

```rust

pub struct Transfer<'info> { Â // <- This 'info is a lifetime

Â  Â  pub account: Account<'info, Data>,

}

```

  

> [!tip] In Simple Terms

> - Rust's memory safety feature

> - Means: "this account lives as long as the instruction execution"

> - Required by Anchor (just always write it)

> - Think of it as: "this data is borrowed for the duration of this instruction"

  

> [!important] Rule

> Always include `'info` in #[derive(Accounts)]

  

---

  

## ğŸ‘¥ 3. ACCOUNT TYPES & VALIDATION

  

### 3.1 Core Account Types

  

**Anchor provides different account types for different purposes:**

  

| Type | Purpose | Check |

|------|---------|-------|

| `Account<'info, T>` | Data account owned by program | Verifies owner = program |

| `Signer<'info>` | Account that signed transaction | Verifies signature |

| `Program<'info, T>` | Another program (for CPI) | Verifies executable |

| `UncheckedAccount<'info>` | Any account (DANGEROUS) | No verification |

| `SystemAccount<'info>` | Regular wallet/account | Basic check |

  

### 3.2 Account<'info, T> - The Standard

  

**Used for:** Data accounts owned by your program

  

```rust

#[derive(Accounts)]

pub struct UpdateProfile<'info> {

Â  Â  #[account(mut)]

Â  Â  pub profile: Account<'info, UserProfile>, Â // <- Owned by this program

Â  Â  pub signer: Signer<'info>,

}

  

#[account]

pub struct UserProfile {

Â  Â  pub name: String,

Â  Â  pub age: u8,

}

  

pub fn update_profile(

Â  Â  ctx: Context<UpdateProfile>,

Â  Â  new_name: String,

) -> Result<()> {

Â  Â  // Automatically verified:

Â  Â  // âœ“ profile.owner == crate::ID (your program)

Â  Â  // âœ“ profile is initialized

Â  Â  // âœ“ profile data is valid

Â  Â  ctx.accounts.profile.name = new_name;

Â  Â  Ok(())

}

```

  

> [!success] What Gets Validated

> - âœ… Account owner is YOUR program

> - âœ… Account is initialized (discriminator matches)

> - âœ… Data can be deserialized as `UserProfile`

> - âŒ Rejects if any check fails

  

### 3.3 Signer<'info> - Signature Verification

  

**Used for:** Accounts that must have signed the transaction

  

```rust

#[derive(Accounts)]

pub struct Create<'info> {

Â  Â  #[account(init, payer = creator, space = 8 + 32)]

Â  Â  pub new_account: Account<'info, Data>,

Â  Â  #[account(mut)]

Â  Â  pub creator: Signer<'info>, Â // <- MUST have signed

Â  Â  pub system_program: Program<'info, System>,

}

  

pub fn create(ctx: Context<Create>) -> Result<()> {

Â  Â  // creator automatically verified as signer

Â  Â  // If not signed, transaction fails before reaching this function

Â  Â  msg!("Creator: {}", ctx.accounts.creator.key());

Â  Â  Ok(())

}

```

  

> [!important] Key Rule

> If you want to verify someone authorized an action, use `Signer<'info>`.

  

### 3.4 Program<'info, T> - For CPIs

  

**Used for:** When you call another program

  

```rust

use anchor_spl::token::Token;

  

#[derive(Accounts)]

pub struct TransferTokens<'info> {

Â  Â  pub token_program: Program<'info, Token>, Â // <- SPL Token Program

Â  Â  // ... other accounts

}

  

pub fn transfer_tokens(ctx: Context<TransferTokens>) -> Result<()> {

Â  Â  // token_program verified as:

Â  Â  // âœ“ executable (is a program)

Â  Â  // âœ“ matches expected program ID

Â  Â  Ok(())

}

```

  

### 3.5 UncheckedAccount<'info> - Use with Caution

  

**Used for:** When you REALLY need to skip validation (rarely!)

  

```rust

#[derive(Accounts)]

pub struct RiskyOperation<'info> {

Â  Â  /// CHECK: We're just reading public data

Â  Â  pub unknown_account: UncheckedAccount<'info>,

}

  

pub fn risky_op(ctx: Context<RiskyOperation>) -> Result<()> {

Â  Â  // NO validation!

Â  Â  // You MUST manually verify in your code

Â  Â  // Only use if you have a very specific reason

Â  Â  Ok(())

}

```

  

> [!warning] Important

> Always add a `/// CHECK:` comment explaining why you're skipping validation.

  

---

  

## ğŸ—ï¸ 4. DEFINING DATA STRUCTURES WITH #[account]

  

### 4.1 Basic Account Definition

  

**Create custom account types:**

  

```rust

use anchor_lang::prelude::*;

  

#[account]

pub struct Counter {

Â  Â  pub count: u64,

Â  Â  pub authority: Pubkey,

}

  

#[account]

pub struct UserProfile {

Â  Â  pub name: String,

Â  Â  pub age: u8,

Â  Â  pub wallet: Pubkey,

Â  Â  pub created_at: i64,

}

```

  

> [!success] What #[account] Does

> - âœ… Automatically implements serialization (Borsh)

> - âœ… Adds 8-byte discriminator (identifies account type)

> - âœ… Makes it usable with `Account<'info, T>`

  

### 4.2 Account Size Calculation

  

**Why size matters:** You pay rent based on account size!

  

**Without InitSpace (manual):**

```rust

#[account]

pub struct Data {

Â  Â  pub owner: Pubkey, Â  Â  Â  // 32 bytes

Â  Â  pub amount: u64, Â  Â  Â  Â  // 8 bytes

Â  Â  pub is_active: bool, Â  Â  // 1 byte

Â  Â  // Total: 41 bytes

}

  

// When creating, add 8 for discriminator:

// space = 8 + 41 = 49 bytes

```

  

**With InitSpace (automatic):**

```rust

#[account]

#[derive(InitSpace)]

pub struct Data {

Â  Â  pub owner: Pubkey, Â  Â  Â  // 32 bytes (auto-counted)

Â  Â  pub amount: u64, Â  Â  Â  Â  // 8 bytes (auto-counted)

Â  Â  pub is_active: bool, Â  Â  // 1 byte (auto-counted)

}

  

// Anchor calculates size automatically!

// space = 8 + Data::INIT_SPACE

```

  

**Always use #[derive(InitSpace)]:**

```rust

#[account]

#[derive(InitSpace)]

pub struct ComplexData {

Â  Â  pub id: u64,

Â  Â  pub owner: Pubkey,

Â  Â  #[max_len(100)] Â // <- Important for Strings!

Â  Â  pub name: String,

Â  Â  pub count: u32,

}

  

// Usage in account creation:

#[derive(Accounts)]

pub struct Create<'info> {

Â  Â  #[account(init, payer = payer, space = 8 + ComplexData::INIT_SPACE)]

Â  Â  pub data: Account<'info, ComplexData>,

Â  Â  #[account(mut)]

Â  Â  pub payer: Signer<'info>,

Â  Â  pub system_program: Program<'info, System>,

}

```

  

### 4.3 Variable-Length Fields

  

**Strings and Vectors need special handling:**

  

```rust

#[account]

#[derive(InitSpace)]

pub struct Profile {

Â  Â  pub id: u64, Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 8 bytes

Â  Â  #[max_len(50)] Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Max 50 chars

Â  Â  pub name: String, Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // 4 (len) + up to 50 bytes

Â  Â  #[max_len(200)] Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Max 200 items

Â  Â  pub tags: Vec<String>, Â  Â  Â  Â  Â  Â  Â  // 4 (len) + variable

Â  Â  pub is_active: bool, Â  Â  Â  Â  Â  Â  Â  Â  // 1 byte

}

// Total: 8 + (4 + 50) + (4 + 200*approx_size) + 1

```

  

> [!tip] Key Rules

> - Always specify `#[max_len(...)]` for variable fields

> - Don't put String fields before fixed-size fields (affects alignment)

> - Consider the data you'll actually store

  

---

  

## ğŸ¬ 5. INSTRUCTIONS & THE #[program] MODULE

  

### 5.1 Writing Instructions

  

**Instructions are just functions in the #[program] module:**

  

```rust

#[program]

pub mod my_program {

Â  Â  use super::*;

  

Â  Â  // Instruction 1: Initialize

Â  Â  pub fn initialize(ctx: Context<Initialize>, param: String) -> Result<()> {

Â  Â  Â  Â  ctx.accounts.data.value = 42;

Â  Â  Â  Â  ctx.accounts.data.owner = ctx.accounts.user.key();

Â  Â  Â  Â  msg!("Initialized with param: {}", param);

Â  Â  Â  Â  Ok(())

Â  Â  }

  

Â  Â  // Instruction 2: Update

Â  Â  pub fn update(ctx: Context<Update>, new_value: u64) -> Result<()> {

Â  Â  Â  Â  require!(new_value > 0, CustomError::InvalidAmount)?;

Â  Â  Â  Â  ctx.accounts.data.value = new_value;

Â  Â  Â  Â  Ok(())

Â  Â  }

  

Â  Â  // Instruction 3: Transfer

Â  Â  pub fn transfer(

Â  Â  Â  Â  ctx: Context<Transfer>,

Â  Â  Â  Â  recipient: Pubkey,

Â  Â  Â  Â  amount: u64,

Â  Â  ) -> Result<()> {

Â  Â  Â  Â  let account = &mut ctx.accounts.data;

Â  Â  Â  Â  require!(account.balance >= amount, CustomError::InsufficientBalance)?;

Â  Â  Â  Â  account.balance -= amount;

Â  Â  Â  Â  // Send to recipient...

Â  Â  Â  Â  Ok(())

Â  Â  }

}

```

  

> [!important] Rules for Instructions

> - âœ… Always return `Result<()>`

> - âœ… First parameter is `ctx: Context<T>`

> - âœ… Additional parameters are instruction arguments

> - âœ… Use `require!` for validation

  

### 5.2 Instruction Parameters

  

**How instruction parameters work:**

  

```rust

pub fn transfer(

Â  Â  ctx: Context<Transfer>, Â // Accounts

Â  Â  recipient: Pubkey, Â  Â  Â  // Instruction parameter 1

Â  Â  amount: u64, Â  Â  Â  Â  Â  Â // Instruction parameter 2

) -> Result<()> {

Â  Â  // Parameters are serialized in transaction

Â  Â  // Clients pass them when calling instruction

Â  Â  Ok(())

}

  

// TypeScript client calling it:

const tx = await program.methods

Â  Â  .transfer(recipientKey, new BN(1000)) Â // <- Pass parameters here

Â  Â  .accounts({...})

Â  Â  .rpc();

```

  

> [!tip] Parameter Rules

> - Must be serializable (standard types, custom structs with Borsh)

> - Complex types should be kept simple (or use instructions-only)

> - Each parameter increases transaction size

  

### 5.3 Accessing Accounts in Instructions

  

**Work with accounts inside your instruction:**

  

```rust

pub fn update_profile(

Â  Â  ctx: Context<UpdateProfile>,

Â  Â  new_name: String,

) -> Result<()> {

Â  Â  // Access account via ctx.accounts

Â  Â  let profile = &mut ctx.accounts.profile;

Â  Â  // Modify data

Â  Â  profile.name = new_name;

Â  Â  profile.updated_at = Clock::get()?.unix_timestamp;

Â  Â  // Access other accounts

Â  Â  msg!("Updated by: {}", ctx.accounts.signer.key());

Â  Â  Ok(())

}

```

  

---

  

## ğŸ”‘ 6. PROGRAM DERIVED ADDRESSES (PDAs) IN CODE

  

### 6.1 Creating PDAs - The Simple Way

  

**Anchor makes PDAs easy:**

  

```rust

#[derive(Accounts)]

pub struct CreateUserVault<'info> {

Â  Â  #[account(

Â  Â  Â  Â  init,

Â  Â  Â  Â  payer = user,

Â  Â  Â  Â  space = 8 + Vault::INIT_SPACE,

Â  Â  Â  Â  seeds = [b"vault", user.key().as_ref()], Â // <- Seeds

Â  Â  Â  Â  bump Â // <- Anchor finds canonical bump automatically

Â  Â  )]

Â  Â  pub vault: Account<'info, Vault>,

Â  Â  #[account(mut)]

Â  Â  pub user: Signer<'info>,

Â  Â  pub system_program: Program<'info, System>,

}

  

#[account]

#[derive(InitSpace)]

pub struct Vault {

Â  Â  pub owner: Pubkey,

Â  Â  pub bump: u8,

Â  Â  pub balance: u64,

}

  

pub fn create_vault(ctx: Context<CreateUserVault>) -> Result<()> {

Â  Â  // PDA automatically created at derived address

Â  Â  let vault = &mut ctx.accounts.vault;

Â  Â  vault.owner = ctx.accounts.user.key();

Â  Â  vault.bump = ctx.bumps.vault; Â // <- Get bump from context

Â  Â  vault.balance = 0;

Â  Â  Ok(())

}

```

  

**What happens here:**

1. `seeds = [b"vault", user.key().as_ref()]` - Define seeds

2. `bump` - Anchor finds canonical bump

3. Account created at derived address automatically

4. `ctx.bumps.vault` - Access the bump that was used

  

### 6.2 Accessing Existing PDAs

  

**To use a PDA that already exists:**

  

```rust

#[derive(Accounts)]

pub struct WithdrawFromVault<'info> {

Â  Â  #[account(

Â  Â  Â  Â  mut,

Â  Â  Â  Â  seeds = [b"vault", user.key().as_ref()],

Â  Â  Â  Â  bump = vault.bump, Â // <- Use stored bump

Â  Â  )]

Â  Â  pub vault: Account<'info, Vault>,

Â  Â  pub user: Signer<'info>,

}

  

pub fn withdraw(ctx: Context<WithdrawFromVault>, amount: u64) -> Result<()> {

Â  Â  require_keys_eq!(ctx.accounts.vault.owner, ctx.accounts.user.key())?;

Â  Â  let vault = &mut ctx.accounts.vault;

Â  Â  require!(vault.balance >= amount)?;

Â  Â  vault.balance -= amount;

Â  Â  Ok(())

}

```

  

**Key difference:**

- **Creating:** `bump` (find it)

- **Verifying:** `bump = vault.bump` (use stored value)

  

### 6.3 Multi-Seed PDAs

  

**Create unique PDAs using multiple seeds:**

  

```rust

#[derive(Accounts)]

pub struct CreateEscrow<'info> {

Â  Â  #[account(

Â  Â  Â  Â  init,

Â  Â  Â  Â  payer = buyer,

Â  Â  Â  Â  space = 8 + Escrow::INIT_SPACE,

Â  Â  Â  Â  seeds = [

Â  Â  Â  Â  Â  Â  b"escrow",

Â  Â  Â  Â  Â  Â  buyer.key().as_ref(),

Â  Â  Â  Â  Â  Â  seller.key().as_ref(),

Â  Â  Â  Â  Â  Â  order_id.to_le_bytes().as_ref(),

Â  Â  Â  Â  ],

Â  Â  Â  Â  bump

Â  Â  )]

Â  Â  pub escrow: Account<'info, Escrow>,

Â  Â  #[account(mut)]

Â  Â  pub buyer: Signer<'info>,

Â  Â  pub seller: SystemAccount<'info>,

Â  Â  pub system_program: Program<'info, System>,

}

  

#[account]

#[derive(InitSpace)]

pub struct Escrow {

Â  Â  pub buyer: Pubkey,

Â  Â  pub seller: Pubkey,

Â  Â  pub order_id: u64,

Â  Â  pub bump: u8,

Â  Â  pub amount: u64,

}

  

pub fn create_escrow(

Â  Â  ctx: Context<CreateEscrow>,

Â  Â  order_id: u64,

Â  Â  amount: u64,

) -> Result<()> {

Â  Â  let escrow = &mut ctx.accounts.escrow;

Â  Â  escrow.buyer = ctx.accounts.buyer.key();

Â  Â  escrow.seller = ctx.accounts.seller.key();

Â  Â  escrow.order_id = order_id;

Â  Â  escrow.bump = ctx.bumps.escrow;

Â  Â  escrow.amount = amount;

Â  Â  Ok(())

}

```

  

> [!info] Seeds Can Include

> - Fixed bytes: `b"escrow"`

> - Pubkeys: `user.key().as_ref()`

> - Numbers: `order_id.to_le_bytes().as_ref()`

> - Any serializable data

  

---

  

## âš™ï¸ 7. CONSTRAINTS DEEP DIVE

  

### 7.1 The Big Picture of Constraints

  

**Constraints are attribute-based validations:**

  

```rust

#[derive(Accounts)]

pub struct Example<'info> {

Â  Â  #[account(

Â  Â  Â  Â  // All these are CONSTRAINTS

Â  Â  Â  Â  init, Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Create account

Â  Â  Â  Â  payer = payer, Â  Â  Â  Â  Â // Who pays

Â  Â  Â  Â  space = 100, Â  Â  Â  Â  Â  Â // How big

Â  Â  Â  Â  seeds = [...], Â  Â  Â  Â  Â // PDA seeds

Â  Â  Â  Â  bump, Â  Â  Â  Â  Â  Â  Â  Â  Â  // Find bump

Â  Â  Â  Â  mut, Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Mutable

Â  Â  Â  Â  signer, Â  Â  Â  Â  Â  Â  Â  Â  // Must sign

Â  Â  Â  Â  close = recipient, Â  Â  Â // Close account

Â  Â  Â  Â  has_one = authority, Â  Â // Verify field

Â  Â  Â  Â  address = EXPECTED_ID, Â // Exact match

Â  Â  )]

Â  Â  pub account: Account<'info, MyData>,

}

```

  

### 7.2 Core Constraints

  

#### #[account(init)]

**Creates a new account:**

  

```rust

#[derive(Accounts)]

pub struct CreateAccount<'info> {

Â  Â  #[account(

Â  Â  Â  Â  init,

Â  Â  Â  Â  payer = user,

Â  Â  Â  Â  space = 8 + 64 Â // Discriminator + data size

Â  Â  )]

Â  Â  pub new_account: Account<'info, MyData>,

Â  Â  #[account(mut)]

Â  Â  pub user: Signer<'info>,

Â  Â  pub system_program: Program<'info, System>,

}

```

  

**Required parameters:**

- `payer = <signer>` - Who pays rent

- `space = <size>` - Account size in bytes

  

#### #[account(init_if_needed)]

**Creates account only if it doesn't exist:**

  

```rust

#[derive(Accounts)]

pub struct InitIfNeeded<'info> {

Â  Â  #[account(

Â  Â  Â  Â  init_if_needed,

Â  Â  Â  Â  payer = user,

Â  Â  Â  Â  space = 64

Â  Â  )]

Â  Â  pub account: Account<'info, MyData>,

Â  Â  #[account(mut)]

Â  Â  pub user: Signer<'info>,

Â  Â  pub system_program: Program<'info, System>,

}

```

  

> [!danger] âš ï¸ Security Warning

> Can be exploited if not careful. Only use when absolutely necessary.

  

#### #[account(mut)]

**Account will be modified:**

  

```rust

#[derive(Accounts)]

pub struct UpdateData<'info> {

Â  Â  #[account(mut)] Â // <- Mark as mutable

Â  Â  pub data: Account<'info, MyData>,

}

  

pub fn update(ctx: Context<UpdateData>) -> Result<()> {

Â  Â  ctx.accounts.data.value = 42; Â // Can write

Â  Â  Ok(())

}

```

  

**Without `mut`:**

- Trying to write fails

- Read-only access

  

#### #[account(signer)]

**Account must have signed:**

  

```rust

#[derive(Accounts)]

pub struct Sign<'info> {

Â  Â  #[account(signer)] Â // <- MUST have signed

Â  Â  pub authority: Signer<'info>,

}

```

  

**Actually, just use `Signer<'info>` type instead:**

```rust

#[derive(Accounts)]

pub struct Sign<'info> {

Â  Â  pub authority: Signer<'info>, Â // Automatically checks signer

}

```

  

#### #[account(seeds, bump)]

**PDA validation:**

  

```rust

#[derive(Accounts)]

pub struct UsePDA<'info> {

Â  Â  #[account(

Â  Â  Â  Â  mut,

Â  Â  Â  Â  seeds = [b"user", user.key().as_ref()],

Â  Â  Â  Â  bump = stored_bump Â // Use stored bump

Â  Â  )]

Â  Â  pub user_account: Account<'info, UserData>,

Â  Â  pub user: Signer<'info>,

}

```

  

#### #[account(has_one = field_name)]

**Verify relationship between accounts:**

  

```rust

#[account]

pub struct Profile {

Â  Â  pub owner: Pubkey, Â // <- Must match signer

Â  Â  pub name: String,

}

  

#[derive(Accounts)]

pub struct UpdateProfile<'info> {

Â  Â  #[account(

Â  Â  Â  Â  mut,

Â  Â  Â  Â  has_one = owner Â // Verify profile.owner == ?

Â  Â  )]

Â  Â  pub profile: Account<'info, Profile>,

Â  Â  pub owner: Signer<'info>, Â // <- Must match profile.owner

}

```

  

**What it does:**

- Verifies `profile.owner == owner.key()`

- Fails if they don't match

  

#### #[account(address = expr)]

**Verify exact address:**

  

```rust

const SYSTEM_PROGRAM_ID: Pubkey = solana_program::system_program::ID;

  

#[derive(Accounts)]

pub struct Example<'info> {

Â  Â  #[account(address = SYSTEM_PROGRAM_ID)]

Â  Â  pub system_program: Program<'info, System>,

}

```

  

#### #[account(close = recipient)]

**Close account and reclaim rent:**

  

```rust

#[derive(Accounts)]

pub struct CloseAccount<'info> {

Â  Â  #[account(

Â  Â  Â  Â  mut,

Â  Â  Â  Â  close = recipient Â // Close and send rent to recipient

Â  Â  )]

Â  Â  pub account_to_close: Account<'info, MyData>,

Â  Â  #[account(mut)]

Â  Â  pub recipient: SystemAccount<'info>,

}

  

pub fn close_account(ctx: Context<CloseAccount>) -> Result<()> {

Â  Â  // Account automatically closed

Â  Â  // Rent automatically transferred to recipient

Â  Â  Ok(())

}

```

  

#### #[account(constraint = expr)]

**Custom validation:**

  

```rust

#[derive(Accounts)]

pub struct Example<'info> {

Â  Â  #[account(

Â  Â  Â  Â  constraint = data.amount > 0 @ CustomError::InvalidAmount

Â  Â  )]

Â  Â  pub data: Account<'info, MyData>,

}

```

  

**Custom error syntax:**

- `condition @ error_code`

- Fails with specific error if false

  

### 7.3 Constraint Combinations

  

**Use multiple constraints together:**

  

```rust

#[derive(Accounts)]

pub struct ComplexExample<'info> {

Â  Â  #[account(

Â  Â  Â  Â  init,

Â  Â  Â  Â  payer = user,

Â  Â  Â  Â  space = 8 + UserData::INIT_SPACE,

Â  Â  Â  Â  seeds = [b"user", user.key().as_ref()],

Â  Â  Â  Â  bump

Â  Â  )]

Â  Â  pub user_data: Account<'info, UserData>,

Â  Â  #[account(mut, has_one = owner)]

Â  Â  pub data_account: Account<'info, DataAccount>,

Â  Â  pub owner: Signer<'info>,

Â  Â  pub system_program: Program<'info, System>,

}

```

  

---

  

## âŒ 8. ERROR HANDLING & CUSTOM ERRORS

  

### 8.1 Defining Custom Errors

  

**Create error codes:**

  

```rust

#[error_code]

pub enum CustomError {

Â  Â  #[msg("Insufficient balance")]

Â  Â  InsufficientBalance,

Â  Â  #[msg("Unauthorized access")]

Â  Â  Unauthorized,

Â  Â  #[msg("Amount must be greater than zero")]

Â  Â  InvalidAmount,

Â  Â  #[msg("Account not initialized")]

Â  Â  NotInitialized,

}

```

  

### 8.2 Using Errors in Instructions

  

**Return errors from instructions:**

  

```rust

pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {

Â  Â  // Check conditions

Â  Â  require!(amount > 0, CustomError::InvalidAmount)?;

Â  Â  require!(

Â  Â  Â  Â  ctx.accounts.from_account.balance >= amount,

Â  Â  Â  Â  CustomError::InsufficientBalance

Â  Â  )?;

Â  Â  // If all checks pass, execute

Â  Â  ctx.accounts.from_account.balance -= amount;

Â  Â  ctx.accounts.to_account.balance += amount;

Â  Â  Ok(())

}

```

  

### 8.3 require! Macro

  

**Validation pattern:**

  

```rust

// Simple require

require!(condition, CustomError::SomeError)?;

  

// With keys (common for authorization)

require_keys_eq!(account1.key(), account2.key(), CustomError::KeyMismatch)?;

  

// With relations

require_keys_eq!(profile.owner, signer.key())?;

  

// Compare values

require_eq!(stored_bump, expected_bump)?;

require_gte!(amount, minimum_amount)?;

require_lt!(index, max_index)?;

```

  

### 8.4 Error vs Result Pattern

  

**Always return Result:**

  

```rust

pub fn good_instruction(ctx: Context<Good>) -> Result<()> {

Â  Â  // Do work

Â  Â  Ok(()) Â // Success

}

  

pub fn bad_function() -> Result<()> {

Â  Â  Err(error!(CustomError::Something)) Â // Explicit error

}

  

pub fn another_bad() -> Result<()> {

Â  Â  require!(false, CustomError::AlwaysFails)?; Â // Returns error

Â  Â  Ok(()) Â // Never reached

}

```

  

---

  

## ğŸ“¢ 9. EVENTS & LOGGING

  

### 9.1 Emitting Events

  

**Create event types:**

  

```rust

#[event]

pub struct Transfer {

Â  Â  #[index] Â // Indexed for efficient filtering

Â  Â  pub from: Pubkey,

Â  Â  #[index]

Â  Â  pub to: Pubkey,

Â  Â  pub amount: u64,

}

  

#[event]

pub struct UserCreated {

Â  Â  #[index]

Â  Â  pub user: Pubkey,

Â  Â  pub name: String,

Â  Â  pub created_at: i64,

}

```

  

### 9.2 Emitting from Instructions

  

**Emit events during execution:**

  

```rust

pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {

Â  Â  ctx.accounts.from_account.balance -= amount;

Â  Â  ctx.accounts.to_account.balance += amount;

Â  Â  // Emit event

Â  Â  emit!(Transfer {

Â  Â  Â  Â  from: ctx.accounts.from_account.key(),

Â  Â  Â  Â  to: ctx.accounts.to_account.key(),

Â  Â  Â  Â  amount,

Â  Â  });

Â  Â  Ok(())

}

  

pub fn create_user(ctx: Context<CreateUser>, name: String) -> Result<()> {

Â  Â  let clock = Clock::get()?;

Â  Â  emit!(UserCreated {

Â  Â  Â  Â  user: ctx.accounts.user.key(),

Â  Â  Â  Â  name,

Â  Â  Â  Â  created_at: clock.unix_timestamp,

Â  Â  });

Â  Â  Ok(())

}

```

  

### 9.3 msg! for Logging

  

**Debug logging:**

  

```rust

pub fn some_instruction(ctx: Context<Example>) -> Result<()> {

Â  Â  msg!("Instruction started");

Â  Â  msg!("User: {}", ctx.accounts.user.key());

Â  Â  msg!("Amount: {}", amount);

Â  Â  // Do work...

Â  Â  msg!("Operation completed successfully");

Â  Â  Ok(())

}

```

  

---

  

## ğŸ”€ 10. CROSS-PROGRAM INVOCATION (CPI)

  

### 10.1 Simple CPI - Transfer SOL

  

**Call System Program to transfer SOL:**

  

```rust

use solana_program::system_instruction;

  

#[derive(Accounts)]

pub struct TransferSol<'info> {

Â  Â  #[account(mut)]

Â  Â  pub from: Signer<'info>,

Â  Â  #[account(mut)]

Â  Â  pub to: SystemAccount<'info>,

Â  Â  pub system_program: Program<'info, System>,

}

  

pub fn transfer_sol(ctx: Context<TransferSol>, amount: u64) -> Result<()> {

Â  Â  // Create instruction

Â  Â  let transfer_ix = system_instruction::transfer(

Â  Â  Â  Â  &ctx.accounts.from.key(),

Â  Â  Â  Â  &ctx.accounts.to.key(),

Â  Â  Â  Â  amount

Â  Â  );

Â  Â  // Create CPI context

Â  Â  let cpi_context = CpiContext::new(

Â  Â  Â  Â  ctx.accounts.system_program.to_account_info(),

Â  Â  Â  Â  transfer_ix,

Â  Â  );

Â  Â  // Invoke

Â  Â  anchor_lang::solana_program::program::invoke(

Â  Â  Â  Â  &transfer_ix,

Â  Â  Â  Â  &[

Â  Â  Â  Â  Â  Â  ctx.accounts.from.to_account_info(),

Â  Â  Â  Â  Â  Â  ctx.accounts.to.to_account_info(),

Â  Â  Â  Â  ],

Â  Â  )?;

Â  Â  Ok(())

}

```

  

### 10.2 CPI with Anchor Helper

  

**Easier way using Anchor helpers:**

  

```rust

use anchor_lang::solana_program::system_instruction;

  

pub fn transfer_sol(ctx: Context<TransferSol>, amount: u64) -> Result<()> {

Â  Â  let cpi_context = CpiContext::new(

Â  Â  Â  Â  ctx.accounts.system_program.to_account_info(),

Â  Â  Â  Â  system_program::Transfer {

Â  Â  Â  Â  Â  Â  from: ctx.accounts.from.to_account_info(),

Â  Â  Â  Â  Â  Â  to: ctx.accounts.to.to_account_info(),

Â  Â  Â  Â  },

Â  Â  );

Â  Â  system_program::transfer(cpi_context, amount)?;

Â  Â  Ok(())

}

```

  

### 10.3 CPI with PDA Signing

  

**When PDA must "sign" the CPI:**

  

```rust

#[derive(Accounts)]

pub struct ReleaseEscrow<'info> {

Â  Â  #[account(

Â  Â  Â  Â  mut,

Â  Â  Â  Â  close = recipient,

Â  Â  Â  Â  seeds = [b"escrow", buyer.key().as_ref()],

Â  Â  Â  Â  bump = escrow.bump,

Â  Â  )]

Â  Â  pub escrow: Account<'info, Escrow>,

Â  Â  #[account(mut)]

Â  Â  pub recipient: SystemAccount<'info>,

Â  Â  pub buyer: Signer<'info>,

Â  Â  pub system_program: Program<'info, System>,

}

  

pub fn release_escrow(ctx: Context<ReleaseEscrow>) -> Result<()> {

Â  Â  let escrow = &ctx.accounts.escrow;

Â  Â  let cpi_context = CpiContext::new_with_signer(

Â  Â  Â  Â  ctx.accounts.system_program.to_account_info(),

Â  Â  Â  Â  system_program::Transfer {

Â  Â  Â  Â  Â  Â  from: escrow.to_account_info(),

Â  Â  Â  Â  Â  Â  to: ctx.accounts.recipient.to_account_info(),

Â  Â  Â  Â  },

Â  Â  Â  Â  &[&[b"escrow", ctx.accounts.buyer.key().as_ref(), &[escrow.bump]]],

Â  Â  );

Â  Â  system_program::transfer(cpi_context, escrow.amount)?;

Â  Â  Ok(())

}

```

  

> [!info] Key Difference

> | Method | Use Case |

> |--------|----------|

> | `CpiContext::new()` | Regular CPI |

> | `CpiContext::new_with_signer()` | PDA "signs" |

  

---

  

## ğŸª™ 11. SPL TOKEN INTEGRATION

  

### 11.1 Token Account Constraints

  

**Working with SPL tokens:**

  

```rust

use anchor_spl::token::{Token, TokenAccount, Mint};

  

#[derive(Accounts)]

pub struct TransferTokens<'info> {

Â  Â  #[account(

Â  Â  Â  Â  mut,

Â  Â  Â  Â  token::mint = mint, Â // Verify it's the right mint

Â  Â  Â  Â  token::authority = authority Â // Verify authority

Â  Â  )]

Â  Â  pub source: Account<'info, TokenAccount>,

Â  Â  #[account(mut)]

Â  Â  pub destination: Account<'info, TokenAccount>,

Â  Â  pub mint: Account<'info, Mint>,

Â  Â  pub authority: Signer<'info>,

Â  Â  pub token_program: Program<'info, Token>,

}

  

pub fn transfer_tokens(ctx: Context<TransferTokens>, amount: u64) -> Result<()> {

Â  Â  let cpi_context = CpiContext::new(

Â  Â  Â  Â  ctx.accounts.token_program.to_account_info(),

Â  Â  Â  Â  token::Transfer {

Â  Â  Â  Â  Â  Â  from: ctx.accounts.source.to_account_info(),

Â  Â  Â  Â  Â  Â  to: ctx.accounts.destination.to_account_info(),

Â  Â  Â  Â  Â  Â  authority: ctx.accounts.authority.to_account_info(),

Â  Â  Â  Â  },

Â  Â  );

Â  Â  token::transfer(cpi_context, amount)?;

Â  Â  Ok(())

}

```

  

### 11.2 Associated Token Accounts (ATAs)

  

**Using Anchor's ATA constraint:**

  

```rust

use anchor_spl::associated_token::AssociatedToken;

use anchor_spl::token::{Token, TokenAccount};

  

#[derive(Accounts)]

pub struct PayWithATA<'info> {

Â  Â  #[account(

Â  Â  Â  Â  init_if_needed,

Â  Â  Â  Â  payer = payer,

Â  Â  Â  Â  associated_token::mint = mint,

Â  Â  Â  Â  associated_token::authority = user

Â  Â  )]

Â  Â  pub user_ata: Account<'info, TokenAccount>,

Â  Â  pub mint: Account<'info, Mint>,

Â  Â  pub user: SystemAccount<'info>,

Â  Â  #[account(mut)]

Â  Â  pub payer: Signer<'info>,

Â  Â  pub token_program: Program<'info, Token>,

Â  Â  pub associated_token_program: Program<'info, AssociatedToken>,

Â  Â  pub system_program: Program<'info, System>,

}

```

  

---

  

## ğŸ§ª 12. TESTING ANCHOR PROGRAMS

  

### 12.1 Basic Test Structure

  

**File: `tests/my_solana_program.ts`**

  

```typescript

import * as anchor from "@coral-xyz/anchor";

import { Program } from "@coral-xyz/anchor";

import { MySolanaProgram } from "../target/types/my_solana_program";

import { assert } from "chai";

  

describe("my_solana_program", () => {

Â  Â  anchor.setProvider(anchor.AnchorProvider.env());

Â  Â  const program = anchor.workspace.MySolanaProgram as Program<MySolanaProgram>;

  

Â  Â  it("Initializes successfully", async () => {

Â  Â  Â  Â  const tx = await program.methods

Â  Â  Â  Â  Â  Â  .initialize()

Â  Â  Â  Â  Â  Â  .rpc();

  

Â  Â  Â  Â  console.log("Transaction:", tx);

Â  Â  });

});

```

  

### 12.2 Testing Instructions

  

**Complete test example:**

  

```typescript

it("Creates and updates account", async () => {

Â  Â  // Generate keypair for new account

Â  Â  const newAccount = anchor.web3.Keypair.generate();

  

Â  Â  // Create account

Â  Â  const createTx = await program.methods

Â  Â  Â  Â  .initialize(new anchor.BN(100))

Â  Â  Â  Â  .accounts({

Â  Â  Â  Â  Â  Â  newAccount: newAccount.publicKey,

Â  Â  Â  Â  Â  Â  user: program.provider.publicKey,

Â  Â  Â  Â  Â  Â  systemProgram: anchor.web3.SystemProgram.programId,

Â  Â  Â  Â  })

Â  Â  Â  Â  .signers([newAccount])

Â  Â  Â  Â  .rpc();

  

Â  Â  // Verify account was created

Â  Â  const account = await program.account.myData.fetch(newAccount.publicKey);

Â  Â  assert.equal(account.value.toNumber(), 100);

  

Â  Â  // Update account

Â  Â  const updateTx = await program.methods

Â  Â  Â  Â  .update(new anchor.BN(200))

Â  Â  Â  Â  .accounts({

Â  Â  Â  Â  Â  Â  account: newAccount.publicKey,

Â  Â  Â  Â  Â  Â  user: program.provider.publicKey,

Â  Â  Â  Â  })

Â  Â  Â  Â  .rpc();

  

Â  Â  // Verify update

Â  Â  const updatedAccount = await program.account.myData.fetch(newAccount.publicKey);

Â  Â  assert.equal(updatedAccount.value.toNumber(), 200);

});

```

  

### 12.3 Testing Error Cases

  

**Verify errors are thrown:**

  

```typescript

it("Fails with invalid amount", async () => {

Â  Â  try {

Â  Â  Â  Â  await program.methods

Â  Â  Â  Â  Â  Â  .transfer(new anchor.BN(0)) Â // Invalid!

Â  Â  Â  Â  Â  Â  .accounts({...})

Â  Â  Â  Â  Â  Â  .rpc();

Â  Â  Â  Â  // Should not reach here

Â  Â  Â  Â  assert.fail("Should have thrown error");

Â  Â  } catch (err) {

Â  Â  Â  Â  // Verify it's the right error

Â  Â  Â  Â  assert.isTrue(err.message.includes("InvalidAmount"));

Â  Â  }

});

```

  

### 12.4 Testing PDAs

  

**Verify PDA derivation:**

  

```typescript

it("Derives PDA correctly", async () => {

Â  Â  const user = program.provider.publicKey;

Â  Â  // Derive PDA on client

Â  Â  const [pda, bump] = await anchor.web3.PublicKey.findProgramAddressSync(

Â  Â  Â  Â  [Buffer.from("user"), user.toBuffer()],

Â  Â  Â  Â  program.programId

Â  Â  );

  

Â  Â  // Create account at PDA

Â  Â  await program.methods

Â  Â  Â  Â  .initializeUser()

Â  Â  Â  Â  .accounts({

Â  Â  Â  Â  Â  Â  userAccount: pda,

Â  Â  Â  Â  Â  Â  user: user,

Â  Â  Â  Â  Â  Â  systemProgram: anchor.web3.SystemProgram.programId,

Â  Â  Â  Â  })

Â  Â  Â  Â  .rpc();

  

Â  Â  // Verify account exists at PDA

Â  Â  const account = await program.account.userAccount.fetch(pda);

Â  Â  assert.ok(account);

});

```

  

---

  

## ğŸ› ï¸ 13. ANCHOR CLI & WORKSPACE

  

### 13.1 Project Structure

  

**Complete Anchor project layout:**

  

```

my_project/

â”œâ”€â”€ Anchor.toml Â  Â  Â  Â  Â  Â  Â # Project config

â”œâ”€â”€ Cargo.toml Â  Â  Â  Â  Â  Â  Â  # Workspace dependencies

â”œâ”€â”€ package.json Â  Â  Â  Â  Â  Â  # Node dependencies

â”œâ”€â”€ programs/

â”‚ Â  â””â”€â”€ my_program/

â”‚ Â  Â  Â  â”œâ”€â”€ Cargo.toml Â  Â  Â  # Program config

â”‚ Â  Â  Â  â””â”€â”€ src/

â”‚ Â  Â  Â  Â  Â  â”œâ”€â”€ lib.rs Â  Â  Â  # Main code

â”‚ Â  Â  Â  Â  Â  â”œâ”€â”€ lib.rs Â  Â  Â  # Helper modules (optional)

â”‚ Â  Â  Â  Â  Â  â””â”€â”€ state.rs Â  Â  # Data structures (optional)

â”œâ”€â”€ tests/

â”‚ Â  â””â”€â”€ my_program.ts Â  Â  Â  Â # Tests

â”œâ”€â”€ target/

â”‚ Â  â”œâ”€â”€ deploy/

â”‚ Â  â”‚ Â  â””â”€â”€ my_program.so Â  Â # Compiled binary

â”‚ Â  â”œâ”€â”€ idl/

â”‚ Â  â”‚ Â  â””â”€â”€ my_program.json Â # IDL

â”‚ Â  â””â”€â”€ types/

â”‚ Â  Â  Â  â””â”€â”€ my_program.ts Â  Â # Generated types

â””â”€â”€ app/ Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  # Frontend (optional)

```

  

### 13.2 Anchor CLI Commands

  

**Essential commands:**

  

```bash

# Initialize new project

anchor init my_project

  

# Build program

anchor build

  

# Test program (with local validator)

anchor test

  

# Deploy to cluster

anchor deploy

  

# Run shell (interactive)

anchor shell

  

# Expand macros (see what derives do)

anchor expand

  

# List all programs

anchor keys list

  

# Sync program IDs

anchor keys sync

```

  

### 13.3 Anchor.toml Configuration

  

**Configure your workspace:**

  

```toml

[package]

name = "my_project"

version = "0.1.0"

description = "My Solana program"

edition = "2021"

  

[programs.localnet]

my_program = "11111111111111111111111111111111"

  

[programs.devnet]

my_program = "2222222222222222222222222222222"

  

[programs.mainnet]

my_program = "3333333333333333333333333333333"

  

[provider]

cluster = "Localnet"

wallet = "~/.config/solana/id.json"

  

[scripts]

test = "yarn run ts-mocha --timeout 60000 tests/**/*.ts"

```

  

---

  

## ğŸ“ 14. IDL & CLIENT GENERATION

  

### 14.1 What is an IDL?

  

**IDL = Interface Definition Language**

  

```json

{

Â  "version": "0.1.0",

Â  "name": "my_program",

Â  "instructions": [

Â  Â  {

Â  Â  Â  "name": "initialize",

Â  Â  Â  "accounts": [...],

Â  Â  Â  "args": [...]

Â  Â  }

Â  ],

Â  "accounts": [

Â  Â  {

Â  Â  Â  "name": "MyData",

Â  Â  Â  "type": {

Â  Â  Â  Â  "kind": "struct",

Â  Â  Â  Â  "fields": [...]

Â  Â  Â  }

Â  Â  }

Â  ]

}

```

  

**Generated automatically when you run:**

```bash

anchor build

```

  

### 14.2 Using Generated Client

  

**TypeScript client automatically generated:**

  

```typescript

import { Program } from "@coral-xyz/anchor";

import idl from "./my_program.json";

  

// TypeScript types are auto-generated

import { MyProgram } from "./target/types/my_program";

  

const program = new Program<MyProgram>(idl, provider);

  

// Now you get autocomplete on methods!

await program.methods.initialize().rpc();

  

// And account types!

const account = await program.account.myData.fetch(pubkey);

```

  

---

  

## ğŸ”’ 15. SECURITY PATTERNS IN CODE

  

### 15.1 Always Validate Accounts

  

```rust

#[derive(Accounts)]

pub struct SecureOperation<'info> {

Â  Â  #[account(

Â  Â  Â  Â  mut,

Â  Â  Â  Â  seeds = [b"vault", user.key().as_ref()],

Â  Â  Â  Â  bump = vault.bump,

Â  Â  Â  Â  has_one = owner, Â // Enforce relationship

Â  Â  )]

Â  Â  pub vault: Account<'info, Vault>,

Â  Â  #[account(

Â  Â  Â  Â  address = TREASURY_ID Â // Exact address match

Â  Â  )]

Â  Â  pub treasury: Account<'info, Treasury>,

Â  Â  pub owner: Signer<'info>,

}

  

pub fn secure_operation(ctx: Context<SecureOperation>) -> Result<()> {

Â  Â  // All validations automatic!

Â  Â  Ok(())

}

```

  

### 15.2 Signer Privilege Rules

  

> [!danger] NEVER Pass User as Signer to Untrusted CPI

> ```rust

> // âŒ WRONG - User signer propagates to untrusted program

> pub fn execute_untrusted(

> Â  Â  ctx: Context<Execute>,

> Â  Â  instruction: Instruction,

> ) -> Result<()> {

> Â  Â  invoke(&instruction, &[ctx.accounts.user.clone(), ...])?;

> Â  Â  Ok(())

> }

> ```

  

> [!success] âœ… Right Way - Don't Pass User Signer

> ```rust

> pub fn execute_trusted(

> Â  Â  ctx: Context<Execute>,

> Â  Â  instruction: Instruction,

> ) -> Result<()> {

> Â  Â  invoke(&instruction, &[vault.clone(), ...])?;

> Â  Â  Ok(())

> }

> ```

  

### 15.3 Anchor Constraints Are Your Friend

  

> [!success] âœ… This is SAFE - Anchor Validates Everything

> ```rust

> #[derive(Accounts)]

> pub struct Safe<'info> {

> Â  Â  #[account(mut, has_one = authority)]

> Â  Â  pub vault: Account<'info, Vault>,

> Â  Â  pub authority: Signer<'info>,

> }

> ```

  

> [!danger] âŒ This is NOT Safe - No Validation

> ```rust

> #[derive(Accounts)]

> pub struct Unsafe<'info> {

> Â  Â  pub vault: UncheckedAccount<'info>,

> Â  Â  pub authority: UncheckedAccount<'info>,

> }

> ```

  

---

  

## ğŸš€ 16. ADVANCED TECHNIQUES

  

### 16.1 Zero-Copy Deserialization

  

**For very large accounts, save compute:**

  

```rust

#[account(zero_copy)]

pub struct LargeData {

Â  Â  pub items: [Item; 10000],

}

  

pub fn read_large_data(ctx: Context<ReadLarge>) -> Result<()> {

Â  Â  let data = ctx.accounts.large_account.load()?;

Â  Â  let first_item = data.items[0];

Â  Â  // No expensive deserialization!

Â  Â  Ok(())

}

```

  

### 16.2 Account Reallocation

  

**Grow accounts dynamically:**

  

```rust

#[derive(Accounts)]

pub struct Reallocate<'info> {

Â  Â  #[account(

Â  Â  Â  Â  mut,

Â  Â  Â  Â  realloc = 1000, Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // New size

Â  Â  Â  Â  realloc::payer = payer, Â  Â  Â  Â  Â  Â // Who pays

Â  Â  Â  Â  realloc::zero = false, Â  Â  Â  Â  Â  Â  // Zero new bytes?

Â  Â  )]

Â  Â  pub account: Account<'info, MyData>,

Â  Â  #[account(mut)]

Â  Â  pub payer: Signer<'info>,

Â  Â  pub system_program: Program<'info, System>,

}

  

pub fn grow_account(ctx: Context<Reallocate>) -> Result<()> {

Â  Â  // Account automatically resized!

Â  Â  Ok(())

}

```

  

### 16.3 Multiple Programs in One Workspace

  

```

programs/

â”œâ”€â”€ program_a/

â”‚ Â  â””â”€â”€ src/lib.rs

â””â”€â”€ program_b/

Â  Â  â””â”€â”€ src/lib.rs

  

Cargo.toml (workspace with both)

Anchor.toml (builds all)

```

  

**Build all:**

```bash

anchor build

```

  

**Build specific:**

```bash

anchor build -p program_a

```

  

---

  

## ğŸ“¦ 17. DEPLOYMENT & UPGRADES

  

### 17.1 Deploying to Devnet

  

**Step by step:**

  

```bash

# 1. Build

anchor build

  

# 2. Get devnet airdrop

solana airdrop 5 -u devnet

  

# 3. Update Anchor.toml to devnet

solana config set --url devnet

  

# 4. Deploy

anchor deploy

  

# 5. Verify deployment

solana program show <PROGRAM_ID> -u devnet

```

  

### 17.2 Making Program Upgradeable

  

**Programs are upgradeable by default (if you have authority).**

  

**But you can lock them:**

  

```bash

solana program set-upgrade-authority <PROGRAM_ID> --final

```

  

**Or transfer authority:**

  

```bash

solana program set-upgrade-authority <PROGRAM_ID> --new-upgrade-authority <NEW_AUTHORITY>

```

  

---

  

## ğŸ’¯ 18. REAL-WORLD EXAMPLE: COMPLETE PROGRAM

  

### 18.1 Todo List Program

  

**A complete example: simple todo list:**

  

```rust

use anchor_lang::prelude::*;

  

declare_id!("11111111111111111111111111111111");

  

#[program]

pub mod todo {

Â  Â  use super::*;

  

Â  Â  pub fn create_todo(

Â  Â  Â  Â  ctx: Context<CreateTodo>,

Â  Â  Â  Â  title: String,

Â  Â  ) -> Result<()> {

Â  Â  Â  Â  require!(!title.is_empty(), TodoError::EmptyTitle)?;

  

Â  Â  Â  Â  let todo_account = &mut ctx.accounts.todo_account;

Â  Â  Â  Â  todo_account.owner = ctx.accounts.owner.key();

Â  Â  Â  Â  todo_account.title = title;

Â  Â  Â  Â  todo_account.completed = false;

Â  Â  Â  Â  todo_account.created_at = Clock::get()?.unix_timestamp;

  

Â  Â  Â  Â  emit!(TodoCreated {

Â  Â  Â  Â  Â  Â  owner: ctx.accounts.owner.key(),

Â  Â  Â  Â  Â  Â  title: todo_account.title.clone(),

Â  Â  Â  Â  });

  

Â  Â  Â  Â  Ok(())

Â  Â  }

  

Â  Â  pub fn complete_todo(ctx: Context<CompleteTodo>) -> Result<()> {

Â  Â  Â  Â  let todo_account = &mut ctx.accounts.todo_account;

Â  Â  Â  Â  require_keys_eq!(

Â  Â  Â  Â  Â  Â  todo_account.owner,

Â  Â  Â  Â  Â  Â  ctx.accounts.owner.key(),

Â  Â  Â  Â  Â  Â  TodoError::Unauthorized

Â  Â  Â  Â  )?;

  

Â  Â  Â  Â  todo_account.completed = true;

  

Â  Â  Â  Â  emit!(TodoCompleted {

Â  Â  Â  Â  Â  Â  owner: ctx.accounts.owner.key(),

Â  Â  Â  Â  Â  Â  title: todo_account.title.clone(),

Â  Â  Â  Â  });

  

Â  Â  Â  Â  Ok(())

Â  Â  }

  

Â  Â  pub fn delete_todo(ctx: Context<DeleteTodo>) -> Result<()> {

Â  Â  Â  Â  require_keys_eq!(

Â  Â  Â  Â  Â  Â  ctx.accounts.todo_account.owner,

Â  Â  Â  Â  Â  Â  ctx.accounts.owner.key(),

Â  Â  Â  Â  Â  Â  TodoError::Unauthorized

Â  Â  Â  Â  )?;

  

Â  Â  Â  Â  Ok(())

Â  Â  }

}

  

#[derive(Accounts)]

#[instruction(title: String)]

pub struct CreateTodo<'info> {

Â  Â  #[account(

Â  Â  Â  Â  init,

Â  Â  Â  Â  payer = owner,

Â  Â  Â  Â  space = 8 + TodoAccount::INIT_SPACE,

Â  Â  Â  Â  seeds = [b"todo", owner.key().as_ref(), title.as_bytes()],

Â  Â  Â  Â  bump

Â  Â  )]

Â  Â  pub todo_account: Account<'info, TodoAccount>,

  

Â  Â  #[account(mut)]

Â  Â  pub owner: Signer<'info>,

  

Â  Â  pub system_program: Program<'info, System>,

}

  

#[derive(Accounts)]

pub struct CompleteTodo<'info> {

Â  Â  #[account(

Â  Â  Â  Â  mut,

Â  Â  Â  Â  seeds = [b"todo", owner.key().as_ref(), todo_account.title.as_bytes()],

Â  Â  Â  Â  bump = todo_account.bump,

Â  Â  )]

Â  Â  pub todo_account: Account<'info, TodoAccount>,

  

Â  Â  pub owner: Signer<'info>,

}

  

#[derive(Accounts)]

pub struct DeleteTodo<'info> {

Â  Â  #[account(

Â  Â  Â  Â  mut,

Â  Â  Â  Â  close = owner,

Â  Â  Â  Â  seeds = [b"todo", owner.key().as_ref(), todo_account.title.as_bytes()],

Â  Â  Â  Â  bump = todo_account.bump,

Â  Â  )]

Â  Â  pub todo_account: Account<'info, TodoAccount>,

  

Â  Â  #[account(mut)]

Â  Â  pub owner: Signer<'info>,

}

  

#[account]

#[derive(InitSpace)]

pub struct TodoAccount {

Â  Â  pub owner: Pubkey,

Â  Â  pub bump: u8,

Â  Â  #[max_len(100)]

Â  Â  pub title: String,

Â  Â  pub completed: bool,

Â  Â  pub created_at: i64,

}

  

#[event]

pub struct TodoCreated {

Â  Â  #[index]

Â  Â  pub owner: Pubkey,

Â  Â  pub title: String,

}

  

#[event]

pub struct TodoCompleted {

Â  Â  #[index]

Â  Â  pub owner: Pubkey,

Â  Â  pub title: String,

}

  

#[error_code]

pub enum TodoError {

Â  Â  #[msg("Title cannot be empty")]

Â  Â  EmptyTitle,

Â  Â  #[msg("Unauthorized access")]

Â  Â  Unauthorized,

}

```

  

### 18.2 Corresponding Tests

  

```typescript

describe("todo", () => {

Â  Â  it("Creates a todo", async () => {

Â  Â  Â  Â  const title = "Buy groceries";

Â  Â  Â  Â  const [todoPda] = await PublicKey.findProgramAddressSync(

Â  Â  Â  Â  Â  Â  [

Â  Â  Â  Â  Â  Â  Â  Â  Buffer.from("todo"),

Â  Â  Â  Â  Â  Â  Â  Â  provider.publicKey.toBuffer(),

Â  Â  Â  Â  Â  Â  Â  Â  Buffer.from(title),

Â  Â  Â  Â  Â  Â  ],

Â  Â  Â  Â  Â  Â  program.programId

Â  Â  Â  Â  );

  

Â  Â  Â  Â  const tx = await program.methods

Â  Â  Â  Â  Â  Â  .createTodo(title)

Â  Â  Â  Â  Â  Â  .accounts({

Â  Â  Â  Â  Â  Â  Â  Â  todoAccount: todoPda,

Â  Â  Â  Â  Â  Â  Â  Â  owner: provider.publicKey,

Â  Â  Â  Â  Â  Â  Â  Â  systemProgram: SystemProgram.programId,

Â  Â  Â  Â  Â  Â  })

Â  Â  Â  Â  Â  Â  .rpc();

  

Â  Â  Â  Â  const todo = await program.account.todoAccount.fetch(todoPda);

Â  Â  Â  Â  assert.equal(todo.title, title);

Â  Â  Â  Â  assert.equal(todo.completed, false);

Â  Â  });

  

Â  Â  it("Completes a todo", async () => {

Â  Â  Â  Â  // ... get todoAccount...

Â  Â  Â  Â  await program.methods

Â  Â  Â  Â  Â  Â  .completeTodo()

Â  Â  Â  Â  Â  Â  .accounts({

Â  Â  Â  Â  Â  Â  Â  Â  todoAccount: todoPda,

Â  Â  Â  Â  Â  Â  Â  Â  owner: provider.publicKey,

Â  Â  Â  Â  Â  Â  })

Â  Â  Â  Â  Â  Â  .rpc();

  

Â  Â  Â  Â  const todo = await program.account.todoAccount.fetch(todoPda);

Â  Â  Â  Â  assert.equal(todo.completed, true);

Â  Â  });

  

Â  Â  it("Fails to complete with wrong owner", async () => {

Â  Â  Â  Â  const wrongOwner = Keypair.generate();

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  await program.methods

Â  Â  Â  Â  Â  Â  Â  Â  .completeTodo()

Â  Â  Â  Â  Â  Â  Â  Â  .accounts({

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  todoAccount: todoPda,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  owner: wrongOwner.publicKey,

Â  Â  Â  Â  Â  Â  Â  Â  })

Â  Â  Â  Â  Â  Â  Â  Â  .signers([wrongOwner])

Â  Â  Â  Â  Â  Â  Â  Â  .rpc();

Â  Â  Â  Â  Â  Â  assert.fail("Should have failed");

Â  Â  Â  Â  } catch (err) {

Â  Â  Â  Â  Â  Â  assert.isTrue(err.message.includes("Unauthorized"));

Â  Â  Â  Â  }

Â  Â  });

});

```

  

---

  

## ğŸ“ KEY TAKEAWAYS

  

> [!abstract]+ For Using Anchor

> 1. **#[derive(Accounts)] is your security layer** â€“ Always use it, never skip

> 2. **Constraints prevent bugs** â€“ Use `#[account(...)]` extensively

> 3. **PDAs are gold** â€“ Use them for deterministic account creation

> 4. **Always validate accounts** â€“ Check owner, signer, relationships

> 5. **Return Result<()>** â€“ Every instruction must handle errors

  

> [!tip]+ Best Practices

> - âœ… Use `#[derive(InitSpace)]` for size calculation

> - âœ… Store bump seeds in accounts

> - âœ… Test error cases as much as success cases

> - âœ… Use `require!` and `require_keys_eq!` for validation

> - âœ… Emit events for important state changes

> - âœ… Document constraints with comments

  

> [!todo] Security Checklist

> - [ ] All account access is validated

> - [ ] Signers are verified for sensitive operations

> - [ ] PDAs use canonical bumps

> - [ ] No hardcoded addresses (use constraints)

> - [ ] No arbitrary CPI calls

> - [ ] No signer privilege reuse

> - [ ] Rent-exempt accounts are verified

  

---

  

## ğŸš€ NEXT STEPS

  

> [!rocket] You're Ready!

> You now have everything you need to build production-grade Solana programs!

  

> [!example]+ Recommended Progression

> 1. Build simple programs (counter, todo list)

> 2. Add PDAs and multi-account operations

> 3. Integrate with SPL tokens

> 4. Implement CPIs to external programs

> 5. Add advanced features (events, error handling)

> 6. Deploy to devnet and mainnet

  

> [!info]+ Resources

> - **Anchor Docs:** https://docs.rs/anchor-lang/

> - **Solana Docs:** https://solana.com/docs

> - **Examples:** https://github.com/coral-xyz/anchor/tree/master/examples

> - **Playground:** https://beta.solpg.io

  

---

  

> [!info] Metadata

> **Last Updated:** December 5, 2025

> **Format:** Obsidian Markdown with Code Examples, Tables, and Best Practices

> **Status:** Ready for Production Use âœ…

>

> #solana #anchor #rust #blockchain #web3 #smart-contracts
